// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package launchdarkly

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a LaunchDarkly team resource.
//
// This resource allows you to create and manage a team within your LaunchDarkly organization.
//
// > **Note:** Teams are available to customers on an Enterprise LaunchDarkly plan. To learn more, read about our pricing. To upgrade your plan, [contact LaunchDarkly Sales](https://launchdarkly.com/contact-sales/).
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/lbrlabs/pulumi-launchdarkly/sdk/go/launchdarkly"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := launchdarkly.NewTeam(ctx, "platformTeam", &launchdarkly.TeamArgs{
//				CustomRoleKeys: pulumi.StringArray{
//					pulumi.String("platform"),
//					pulumi.String("nomad-administrators"),
//				},
//				Description: pulumi.String("Team to manage internal infrastructure"),
//				Key:         pulumi.String("platform_team"),
//				Maintainers: pulumi.StringArray{
//					pulumi.String("12ab3c45de678910abc12345"),
//				},
//				MemberIds: pulumi.StringArray{
//					pulumi.String("507f1f77bcf86cd799439011"),
//					pulumi.String("569f183514f4432160000007"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// # A LaunchDarkly team can be imported using the team key
//
// ```sh
//
//	$ pulumi import launchdarkly:index/team:Team platform_team platform_team
//
// ```
type Team struct {
	pulumi.CustomResourceState

	// List of custom role keys the team will access. The referenced custom roles must already exist in LaunchDarkly. If they don't, the provider may behave unexpectedly.
	CustomRoleKeys pulumi.StringArrayOutput `pulumi:"customRoleKeys"`
	// The team description.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The team key.
	Key pulumi.StringOutput `pulumi:"key"`
	// List of member IDs for users who maintain the team.
	Maintainers pulumi.StringArrayOutput `pulumi:"maintainers"`
	// List of member IDs who belong to the team.
	MemberIds pulumi.StringArrayOutput `pulumi:"memberIds"`
	// A human-friendly name for the team.
	Name pulumi.StringOutput `pulumi:"name"`
}

// NewTeam registers a new resource with the given unique name, arguments, and options.
func NewTeam(ctx *pulumi.Context,
	name string, args *TeamArgs, opts ...pulumi.ResourceOption) (*Team, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Key == nil {
		return nil, errors.New("invalid value for required argument 'Key'")
	}
	opts = pkgResourceDefaultOpts(opts)
	var resource Team
	err := ctx.RegisterResource("launchdarkly:index/team:Team", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetTeam gets an existing Team resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetTeam(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *TeamState, opts ...pulumi.ResourceOption) (*Team, error) {
	var resource Team
	err := ctx.ReadResource("launchdarkly:index/team:Team", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Team resources.
type teamState struct {
	// List of custom role keys the team will access. The referenced custom roles must already exist in LaunchDarkly. If they don't, the provider may behave unexpectedly.
	CustomRoleKeys []string `pulumi:"customRoleKeys"`
	// The team description.
	Description *string `pulumi:"description"`
	// The team key.
	Key *string `pulumi:"key"`
	// List of member IDs for users who maintain the team.
	Maintainers []string `pulumi:"maintainers"`
	// List of member IDs who belong to the team.
	MemberIds []string `pulumi:"memberIds"`
	// A human-friendly name for the team.
	Name *string `pulumi:"name"`
}

type TeamState struct {
	// List of custom role keys the team will access. The referenced custom roles must already exist in LaunchDarkly. If they don't, the provider may behave unexpectedly.
	CustomRoleKeys pulumi.StringArrayInput
	// The team description.
	Description pulumi.StringPtrInput
	// The team key.
	Key pulumi.StringPtrInput
	// List of member IDs for users who maintain the team.
	Maintainers pulumi.StringArrayInput
	// List of member IDs who belong to the team.
	MemberIds pulumi.StringArrayInput
	// A human-friendly name for the team.
	Name pulumi.StringPtrInput
}

func (TeamState) ElementType() reflect.Type {
	return reflect.TypeOf((*teamState)(nil)).Elem()
}

type teamArgs struct {
	// List of custom role keys the team will access. The referenced custom roles must already exist in LaunchDarkly. If they don't, the provider may behave unexpectedly.
	CustomRoleKeys []string `pulumi:"customRoleKeys"`
	// The team description.
	Description *string `pulumi:"description"`
	// The team key.
	Key string `pulumi:"key"`
	// List of member IDs for users who maintain the team.
	Maintainers []string `pulumi:"maintainers"`
	// List of member IDs who belong to the team.
	MemberIds []string `pulumi:"memberIds"`
	// A human-friendly name for the team.
	Name *string `pulumi:"name"`
}

// The set of arguments for constructing a Team resource.
type TeamArgs struct {
	// List of custom role keys the team will access. The referenced custom roles must already exist in LaunchDarkly. If they don't, the provider may behave unexpectedly.
	CustomRoleKeys pulumi.StringArrayInput
	// The team description.
	Description pulumi.StringPtrInput
	// The team key.
	Key pulumi.StringInput
	// List of member IDs for users who maintain the team.
	Maintainers pulumi.StringArrayInput
	// List of member IDs who belong to the team.
	MemberIds pulumi.StringArrayInput
	// A human-friendly name for the team.
	Name pulumi.StringPtrInput
}

func (TeamArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*teamArgs)(nil)).Elem()
}

type TeamInput interface {
	pulumi.Input

	ToTeamOutput() TeamOutput
	ToTeamOutputWithContext(ctx context.Context) TeamOutput
}

func (*Team) ElementType() reflect.Type {
	return reflect.TypeOf((**Team)(nil)).Elem()
}

func (i *Team) ToTeamOutput() TeamOutput {
	return i.ToTeamOutputWithContext(context.Background())
}

func (i *Team) ToTeamOutputWithContext(ctx context.Context) TeamOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TeamOutput)
}

// TeamArrayInput is an input type that accepts TeamArray and TeamArrayOutput values.
// You can construct a concrete instance of `TeamArrayInput` via:
//
//	TeamArray{ TeamArgs{...} }
type TeamArrayInput interface {
	pulumi.Input

	ToTeamArrayOutput() TeamArrayOutput
	ToTeamArrayOutputWithContext(context.Context) TeamArrayOutput
}

type TeamArray []TeamInput

func (TeamArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Team)(nil)).Elem()
}

func (i TeamArray) ToTeamArrayOutput() TeamArrayOutput {
	return i.ToTeamArrayOutputWithContext(context.Background())
}

func (i TeamArray) ToTeamArrayOutputWithContext(ctx context.Context) TeamArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TeamArrayOutput)
}

// TeamMapInput is an input type that accepts TeamMap and TeamMapOutput values.
// You can construct a concrete instance of `TeamMapInput` via:
//
//	TeamMap{ "key": TeamArgs{...} }
type TeamMapInput interface {
	pulumi.Input

	ToTeamMapOutput() TeamMapOutput
	ToTeamMapOutputWithContext(context.Context) TeamMapOutput
}

type TeamMap map[string]TeamInput

func (TeamMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Team)(nil)).Elem()
}

func (i TeamMap) ToTeamMapOutput() TeamMapOutput {
	return i.ToTeamMapOutputWithContext(context.Background())
}

func (i TeamMap) ToTeamMapOutputWithContext(ctx context.Context) TeamMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(TeamMapOutput)
}

type TeamOutput struct{ *pulumi.OutputState }

func (TeamOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Team)(nil)).Elem()
}

func (o TeamOutput) ToTeamOutput() TeamOutput {
	return o
}

func (o TeamOutput) ToTeamOutputWithContext(ctx context.Context) TeamOutput {
	return o
}

// List of custom role keys the team will access. The referenced custom roles must already exist in LaunchDarkly. If they don't, the provider may behave unexpectedly.
func (o TeamOutput) CustomRoleKeys() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Team) pulumi.StringArrayOutput { return v.CustomRoleKeys }).(pulumi.StringArrayOutput)
}

// The team description.
func (o TeamOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Team) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The team key.
func (o TeamOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v *Team) pulumi.StringOutput { return v.Key }).(pulumi.StringOutput)
}

// List of member IDs for users who maintain the team.
func (o TeamOutput) Maintainers() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Team) pulumi.StringArrayOutput { return v.Maintainers }).(pulumi.StringArrayOutput)
}

// List of member IDs who belong to the team.
func (o TeamOutput) MemberIds() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Team) pulumi.StringArrayOutput { return v.MemberIds }).(pulumi.StringArrayOutput)
}

// A human-friendly name for the team.
func (o TeamOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Team) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

type TeamArrayOutput struct{ *pulumi.OutputState }

func (TeamArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Team)(nil)).Elem()
}

func (o TeamArrayOutput) ToTeamArrayOutput() TeamArrayOutput {
	return o
}

func (o TeamArrayOutput) ToTeamArrayOutputWithContext(ctx context.Context) TeamArrayOutput {
	return o
}

func (o TeamArrayOutput) Index(i pulumi.IntInput) TeamOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Team {
		return vs[0].([]*Team)[vs[1].(int)]
	}).(TeamOutput)
}

type TeamMapOutput struct{ *pulumi.OutputState }

func (TeamMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Team)(nil)).Elem()
}

func (o TeamMapOutput) ToTeamMapOutput() TeamMapOutput {
	return o
}

func (o TeamMapOutput) ToTeamMapOutputWithContext(ctx context.Context) TeamMapOutput {
	return o
}

func (o TeamMapOutput) MapIndex(k pulumi.StringInput) TeamOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Team {
		return vs[0].(map[string]*Team)[vs[1].(string)]
	}).(TeamOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*TeamInput)(nil)).Elem(), &Team{})
	pulumi.RegisterInputType(reflect.TypeOf((*TeamArrayInput)(nil)).Elem(), TeamArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*TeamMapInput)(nil)).Elem(), TeamMap{})
	pulumi.RegisterOutputType(TeamOutput{})
	pulumi.RegisterOutputType(TeamArrayOutput{})
	pulumi.RegisterOutputType(TeamMapOutput{})
}
